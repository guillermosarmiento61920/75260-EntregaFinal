// server.js
import express from "express";
import { connectMongoDB } from "./daos/mongodb/connection.js";
import { errorHandler } from "./middlewares/errorHandler.js";
import userRouter from "./routes/userRouter.js";
import cookieParser from "cookie-parser";
import handlebars from "express-handlebars";
import viewsRouter from "./routes/viewsRouter.js";
import session from "express-session";
import mongoStore from "connect-mongo";
import passport from "passport";
import './config/jwtStrategy.js'
import sessionRouter from "./routes/sessionRouter.js"

const app = express();
const PORT = 8080;

app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.use(cookieParser(process.env.SECRET_KEY));

app.engine("handlebars", handlebars.engine());
app.set("views","src/views");
app.set("view engine", "handlebars");

const sessionConfig = {
  secret: process.env.SECRET_KEY,
  resave: false,
  saveUninitialized: false,
  cookie: {
    maxAge: 60000,
  },
  store: new mongoStore({
    mongoUrl: process.env.MONGODB_URI,
    ttl: 60,
  }),
};

app.use(session(sessionConfig));

app.use(passport.initialize());
app.use(passport.session());

app.use("/users", userRouter);
app.use("/", viewsRouter);
app.use("/api/sessions", sessionRouter);

app.use(errorHandler);

connectMongoDB()
  .then(() => console.log("Conectado a mongodb"))
  .catch((error) => console.log(error));

app.listen(PORT, () => console.log(`Server listening on http://localhost:${PORT}`));

{{!-- error.handlebars --}}
<h1>Error {{status}}</h1>
<p>{{message}}</p>

{{!-- errorLogin.handlebars --}}
<h2>EMAIL O CONTRASENA INCORRECTO</h2>
<button onclick="location.href='/'">Ir a login</button>

{{!-- errorRegistro.handlebars --}}
<h2>ESTE USUARIO YA EXISTE</h2>
<button onclick="location.href='/'">Ir a login</button>

{{!-- login.handlebars --}}
<h1>Login</h1>
<form action='/users/login' method='post'>
  Email: <input type='email' name='email' id='email' />
  Password: <input type='password' name='password' id='password' />
  <input type='submit' value='INGRESAR' />
</form>

<h2>USUARIO NUEVO?</h2>
<button onclick="location.href='/registro'">Ir a registro</button>

{{!-- perfil.handlebars --}}
<h2>PERFIL</h2>
<h3>Â¡Bienvenido/a {{user.email}}!</h3>

{{!-- registro.handlebars --}}
<h1>REGISTRO</h1>

<form action="/users/register" method="post">
  <label for="first_name">FirstName:</label> <input type="text" name="first_name" id="first_name" placeholder="Escribe tu nombre" />
  <label for="last_name">LastName:</label> <input type="text" name="last_name" id="last_name" placeholder="Escribe tu Apellido" />
  <label for="email">Email:</label> <input type="email" name="email" id="email" placeholder="Ejemplo@mail.com" />
  <label for="age">Age:</label> <input type="number" name="age" id="age" placeholder="Tu edad en numeros" />
  <label for="password">Password:</label> <input type="password" name="password" id="password" placeholder="Contrasena" />
  <input type="submit" value="CREAR" />
</form>

// customError.js
export default class CustomError extends Error {
    constructor(message, status){
        super(message);
        this.status = status;
    }
}

// userUtils.js
import bcrypt from "bcrypt";

export const createHash = (password) => {
  return bcrypt.hashSync(password, bcrypt.genSaltSync(10));
};

export const isValidPassword = (password, passwordHash) => {
  return bcrypt.compareSync(password, passwordHash);
}; 

// userService.js
import { userDao } from "../daos/mongodb/userDao.js";
import CustomError from "../utils/customError.js";
import { createHash, isValidPassword } from "../utils/userUtils.js";
import jwt from "jsonwebtoken";
import "dotenv/config";

class UserService {
  constructor(dao) {
    this.dao = dao;
  }

register = async (body) => {
    try {
      const { email, password, ...rest } = body;
      const existUser = await this.dao.getByEmail(email);
      if (existUser) throw new CustomError("El usuario ya existe", 400);

      const hashedPassword = createHash(password)
      console.log("contra hasheada", hashedPassword);

const userData = {
  ...rest,
  email,
  password: hashedPassword
};
      const response = await this.dao.create(userData);
      if (!response) throw new CustomError("Error al registrar usuario", 400);

      return response;
    } catch (error) {
      throw error;
    }
  };

  login = async (email, password) => {
     try {
       const userExist = await this.dao.getByEmail(email);
       if (!userExist) throw new CustomError("Credenciales incorrectas", 400);
       const passValid = isValidPassword(password, userExist.password);
       if (!passValid) throw new CustomError("Credenciales incorrectas", 400);
       return userExist;
     } catch (error) {
       throw error;
     }
   };

generateToken = (user) => {
    const payload = {
      _id: user._id,
      first_name: user.first_name,
      last_name: user.last_name,
      email: user.email,
      role: user.role,
    };
    return jwt.sign(payload, process.env.JWT_SECRET, {
      expiresIn: "20m",
    });
  };

  getAll = async () => {
    try {
      return await this.dao.getAll();
    } catch (error) {
      throw new Error(error);
    }
  };

  getById = async (id) => {
    try {
      const response = await this.dao.getById(id);
      if (!response) throw new CustomError("Not found", 404);
      return response;
    } catch (error) {
      throw error;
    }
  };

  create = async (body) => {
    try {
      const response = await this.dao.create(body);
      if (!response) throw new CustomError("Error creating product", 404);
      return response;
    } catch (error) {
      throw(error);
    }
  };

  update = async (id, body) => {
    try {
      const response = await this.dao.update(id, body);
      if (!response) throw new CustomError("Not found", 404);
      return response;
    } catch (error) {
      throw(error);
    }
  };

  delete = async (id) => {
    try {
      const response = await this.dao.delete(id);
      if (!response) throw new CustomError("Not found", 404);
      return response;
    } catch (error) {
      throw(error);
    }
  };
}

export const userService = new UserService(userDao);

// sessionRouter.js
import { Router } from "express";
import passport from "passport";

const router = Router();

router.get(
  "/current",
  passport.authenticate("current", { session: false }),
  (req, res) => {
    res.status(200).json({
      status: "success",
      user: req.user,
    });
  }
);

export default router;

// userRouter.js
import { Router } from "express";
import { userController } from "../controllers/userController.js";
import passport from "passport";
import { checkRole } from "../middlewares/checkRole.js";

const router = Router();

router.post("/register", userController.register);
router.post("/login", userController.login);
router.get("/private-headers", passport.authenticate("jwt"), (req, res) => res.send(req.user));
router.get("/private-cookies",passport.authenticate("jwt-cookies"),(req, res) => res.send(req.user));
router.get("/private-cookies-admin",passport.authenticate("jwt-cookies"),checkRole("admin"),(req, res) => res.send(req.user));

router.get("/", userController.getAll);
router.get("/:id", userController.getById);
router.post("/", userController.create);
router.put("/:id", userController.update);
router.delete("/:id", userController.delete);

export default router;

// viewsRouter.js
import { Router } from "express";

const router = Router()

router.get('/', (req, res) => {
    res.render('login')
})

router.get("/registro", (req, res) => {
    res.render("registro");
});

router.get("/errorRegistro", (req, res) => {
    res.render("errorRegistro");
});

router.get("/errorLogin", (req, res) => {
    res.render("errorLogin");
});

router.get("/perfil", (req, res) => {
    if (!req.user) return res.redirect("/errorLogin");

    res.render("perfil", { user: req.user });
});

export default router

// checkRole.js
export const checkRole = (role) => {
    return (req, res, next) => {
      if (!req.user) {
        return res.status(401).send({ status: "error", error: "Unauthorized" });
      }

      if (req.user.role !== role) {
        return res
          .status(403)
          .send({ status: "error", error: "You do not have permissions" });
      }
      
          next()
    };
  };
  
// errorHandler.js
export const errorHandler = (error, req, res) => {
    const status = error.status || 500;
    const message = error.message || "Unexpected error";

  res.status(status).render("error", { status, message });
};

// user.model.js
import mongoose, { Schema, model } from "mongoose";
// import { userController } from "../../..userController.js";

const UserSchema = new Schema({
  first_name: { type: String, required: true },
  last_name: { type: String, required: true },
  email: {type: String, unique: true},
  age: { type: Number, required: true },
  password: {type: String, required: true},
  cart: {type: Schema.Types.ObjectId, ref: "Cart"},
  role: { type: String, required: true, default: 'user' },
});

export const UserModel = model("user", UserSchema);

// connection.js
import { connect } from "mongoose";
import "dotenv/config";

export const connectMongoDB = async () => {
  try {
    await connect(process.env.MONGODB_URI);
  console.log("conectado correctamente a MongoDB!");
  } catch (error) {
    throw new Error(error);
  }
};

// mongoDao.js
export default class MongoDao {
  constructor(model) {
    this.model = model;
  }

  create = async (body) => {
    try {
      return await this.model.create(body);
    } catch (error) {
      throw new Error(error);
    }
  };

  getAll = async () => {
    try {
      return await this.model.find({});
    } catch (error) {
      throw new Error(error);
    }
  };

  getById = async (id) => {
    try {
      return await this.model.findById(id);
    } catch (error) {
      throw new Error(error);
    }
  };

  update = async (id, body) => {
    try {
      return await this.model.findByIdAndUpdate(id, body, { new: true });
    } catch (error) {
      throw new Error(error);
    }
  };

  delete = async (id) => {
    try {
      return await this.model.findByIdAndDelete(id);
    } catch (error) {
      throw new Error(error);
    }
  };
}

// userDao.js
import { UserModel } from "./models/user.model.js";
import MongoDao from "./mongoDao.js";

class UserDaoMongo extends MongoDao {
    constructor(model) {
        super(model);
    }
    getByEmail = async (email) => {
        try {
          return await this.model.findOne({ email }).populate("cart").lean();
        } catch (error) {
          throw new Error(error);
        }
      };
}

export const userDao = new UserDaoMongo(UserModel);

// userController.js
import { userService } from "../services/userService.js";

class UserController {
  constructor(service) {
    this.service = service;
  }

  register = async (req, res, next) => {
    try {
      console.log("[CONTROLLER DEBUG] Body recibido:", req.body);
      await this.service.register(req.body);
      if (req.accepts("html")) return res.redirect("/");
      res.status(201).json({ message: "Usuario registrado correctamente" });
    } catch (error) {
      next(error);
    }
  };

  login = async (req, res, next) => {
    try {
      const { email, password } = req.body;
      const user = await this.service.login(email, password);
      const token = this.service.generateToken(user);
      res.cookie("token", token, { httpOnly: true }).json({ user, token });
    } catch (error) {
      next(error);
    }
  };

  getAll = async (req, res, next) => {
    try {
      const response = await this.service.getAll();
      res.status(200).json(response);
    } catch (error) {
      next(error);
    }
  };

  getById = async (req, res, next) => {
    try {
      const { id } = req.params;
      const response = await this.service.getById(id);
      res.status(200).json(response);
    } catch (error) {
      next(error);
    }
  };

  create = async (req, res, next) => {
    try {
      const response = await this.service.create(req.body);
      if (!response) return res.redirect("/errorRegistro");
      res.status(201).json(response);
    } catch (error) {
      next(error);
    }
  };

  update = async (req, res, next) => {
    try {
      const { id } = req.params;
      const response = await this.service.update(id, req.body);
      if (!response) return res.status(404).json({ message: "Usuario no encontrado" });
      res.status(200).json(response);

    } catch (error) {
      next(error);
    }
  };

  delete = async (req, res, next) => {
    try {
      const { id } = req.params;
      const response = await this.service.delete(id);
      if (!response) return res.status(404).json({ message: "Usuario no encontrado" });
      res.status(200).json(response);

    } catch (error) {
      next(error);
    }
  };
}

export const userController = new UserController(userService)

// jwtStrategy.js
import passport from "passport";
import { ExtractJwt, Strategy } from "passport-jwt";
import { userService } from "../services/userService.js";
import "dotenv/config";

const verifyToken = async (jwt_payload, done) => {
  if (!jwt_payload) return done(null, false, { messages: "Invalid Token" });
  return done(null, jwt_payload);
};

const cookieExtractor = (req) => {
  return req.cookies.token;
};

const strategyConfigCurrent = {
  jwtFromRequest: ExtractJwt.fromExtractors([cookieExtractor]),
  secretOrKey: process.env.JWT_SECRET,
};

passport.use("current", new Strategy(strategyConfigCurrent, verifyToken));

const strategyConfigCookies = {
    jwtFromRequest: ExtractJwt.fromExtractors([cookieExtractor]),
    secretOrKey: process.env.JWT_SECRET
};

passport.use('jwt-cookies', new Strategy(strategyConfigCookies, verifyToken));

// passport.serializeUser((user, done) => {
//   try {
//     done(null, user._id);
//   } catch (error) {
//     done(error);
//   }
// });

// passport.deserializeUser(async (id, done) => {
//   try {
//     const user = await userService.getById(id);
//     return done(null, user);
//   } catch (error) {
//     done(error);
//   }
// });
